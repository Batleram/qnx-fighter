/*
 * $QNXLicenseC:
 * Copyright 2019, QNX Software Systems. All Rights Reserved.
 *
 * You must obtain a written license from and pay applicable license fees to QNX
 * Software Systems before you may reproduce, modify or distribute this software,
 * or any work that includes all or part of this software.   Free development
 * licenses are available for evaluation and non-commercial purposes.  For more
 * information visit http://licensing.qnx.com or email licensing@qnx.com.
 *
 * This file may contain contributions from others.  Please review this entire
 * file for other proprietary rights or license notices, as well as the QNX
 * Development Suite License Guide at http://licensing.qnx.com/license-guide/
 * for other information.
 * $
 */

/**
 * @file    pwm.c
 * @brief   Pulse width modulation support
 *
 * The Raspberry Pi only supports hardware PWM on GPIO 18. It is driven by the
 * PWM clock, which is not documented in the BCM2835 data sheet. Some
 * information can be found in
 * https://www.scribd.com/doc/127599939/BCM2835-Audio-clocks
 * and in the WiringPi source code.
 *
 * This module also implements software PWM for all other GPIOs, using the
 * system timer. The implementation is mostly in the timer's ISR (interrupt 1)
 * to allow for a high interrupt frequency. The system timer's frequency is
 * 1MHz, so all timer values are in microseconds.
 */

#include <stdio.h>
#include <time.h>
#include <errno.h>
#include <pthread.h>
#include <sys/mman.h>
#include <aarch64/inline.h>
#include <aarch64/rpi_gpio.h>
#include <sys/rpi_gpio.h>
#include "rpi_gpio_priv.h"

typedef struct pwm  pwm_t;

/**
 * PWM state for a single GPIO.
 * Whether the GPIO is driven by hardware or software PWM is determined by the
 * channel field (non zero or zero, respectively). Most fields are only used for
 * software PWM.
 */
struct pwm
{
    rcvid_t     rcvid;
    unsigned    gpio;
    unsigned    channel;
    unsigned    func;
    unsigned    frequency;
    unsigned    range;
    unsigned    duty;
    int         state;
    unsigned    time_on;
    unsigned    time_off;
    unsigned    last_change;
};

/**
 * System timer registers.
 */
enum
{
    REG_STCS = 0,
    REG_STCLO = 1,
    REG_STCHI = 2,
    REG_STC0 = 3,
    REG_STC1 = 4,
    REG_STC2 = 5,
    REG_STC3 = 6,
};

/*
 * PWM registers.
 */
enum
{
    REG_PWMCTL = 0,
    REG_PWMSTA = 1,
    REG_PWMDMAC = 2,
    REG_PWMRNG1 = 4,
    REG_PWMDATA1 = 5,
    REG_PWMFIF1 = 6,
    REG_PWMRNG2 = 8,
    REG_PWMDATA2 = 9
};

#define NUM_SOFT_PWM        8
#define MIN_INTR_INTERVAL   20

static uint32_t volatile    *pwm_regs;
static uint32_t volatile    *clk_regs;
static uint32_t volatile    *timer_regs;
static pwm_t                soft_pwm[NUM_SOFT_PWM];
static int                  timer_intr_id = -1;
static int                  timer_intr_ready;
static unsigned             timer_intrs;

static pwm_t    pwm_gpio_12 = {
    .gpio = 12,
    .channel = 1,
    .func = RPI_GPIO_FUNC_ALT_0
};

static pwm_t    pwm_gpio_13 = {
    .gpio = 13,
    .channel = 2,
    .func = RPI_GPIO_FUNC_ALT_0
};

static pwm_t    pwm_gpio_18 = {
    .gpio = 18,
    .channel = 1,
    .func = RPI_GPIO_FUNC_ALT_5
};

static pwm_t    pwm_gpio_19 = {
    .gpio = 19,
    .channel = 2,
    .func = RPI_GPIO_FUNC_ALT_5
};

/**
 * Maps gpio number to pwm_t structure.
 * Only GPIOs actively managed by PWM have non-NULL entries.
 */
static pwm_t   *pwm_map[RPI_GPIO_NUM] = {
    [12] = &pwm_gpio_12,
    [13] = &pwm_gpio_13,
    [18] = &pwm_gpio_18,
    [19] = &pwm_gpio_19,
};

/**
 * Interrupt service routine attached to interrupt 1 (system timer).
 * The ISR is called every time the timer's lower bits (register 1) match the
 * comparator (register 4).
 * @param   area    Ignored
 * @param   id      Ignored
 * @return  Always NULL (no event is queued)
 */
static struct sigevent const *
timer_isr(void *area, int id)
{
    unsigned const  cur_time = timer_regs[REG_STCLO];
    unsigned        next_min = -1U;

    if ((timer_regs[REG_STCS] & 2) == 0) {
        // Ignore spurious interrupts not generated by a match.
        return NULL;
    }

    if (!timer_intr_ready) {
        // Interrupt from a previous match, ignore.
        timer_regs[REG_STCS] = 2;
        return NULL;
    }

    for (unsigned i = 0; i < NUM_SOFT_PWM; i++) {
        // Skip unused slots.
        if (soft_pwm[i].gpio == 0) {
            continue;
        }

        // Skip disabled slots.
        if (soft_pwm[i].duty == 0) {
            continue;
        }

        // Check if the GPIO should change its state.
        pwm_t * const   pwm = &soft_pwm[i];
        unsigned const  pwm_time = pwm->state ? pwm->time_on : pwm->time_off;
        unsigned        next;

        if ((cur_time - pwm->last_change) > pwm_time) {
            // Toggle the GPIO.
            pwm->state = !pwm->state;
            if (pwm->state) {
                rpi_gpio_set(pwm->gpio);
            } else {
                rpi_gpio_clear(pwm->gpio);
            }

            // Record the change time based on what it should have been, not
            // what it was.
            pwm->last_change += pwm_time;
            next = pwm->state ? pwm->time_on : pwm->time_off;
        } else {
            next = (pwm->last_change + pwm_time) - cur_time;
        }

        if (next < next_min) {
            next_min = next;
        }
    }

    if ((int)next_min < MIN_INTR_INTERVAL) {
        // Avoid a flood.
        next_min = MIN_INTR_INTERVAL;
    }

    // Reload comparator.
    timer_regs[REG_STC1] = timer_regs[REG_STCLO] + next_min;

    // Clear match.
    timer_regs[REG_STCS] = 2;

    timer_intrs++;
    return NULL;
}

/**
 * Interrupt thread for the system timer.
 * @param   arg Ignored
 */
static void *
timer_ist(void * const arg)
{
    if (verbose) {
        printf("Timer IST starting\n");
    }

    // Set priority.
    // FIXME: Switch to IST policy and increase priority?
    struct sched_param sched = { .sched_priority = 220 };
    if (SchedSet(0, 0, SCHED_FIFO, &sched) == -1) {
        perror("SchedSet");
        return NULL;
    }

    // System timer 1 interrupt is mapped to VC interrupt 1.
    // On RPI3 VC IRQs start at 0, on RPI4 at 96.
    unsigned intr = 1;
    if (rpi_version() == RPI_VER_4) {
        intr += 96;
    }

    // Attach to interrupt.
    timer_intr_id = InterruptAttachThread(intr, 0);
    if (timer_intr_id == -1) {
        perror("InterruptAttachThread");
        return NULL;
    }

    for (;;) {
        InterruptWait(_NTO_INTR_WAIT_FLAGS_FAST | _NTO_INTR_WAIT_FLAGS_UNMASK, NULL);
        timer_isr(NULL, timer_intr_id);
    }
}

/**
 * Initializes the system timer interrupt for software PWM.
 * @param   time    Time to the next timer interrupt needed for a new PWM entry
 * @return  0 if successful, error code otherwise
 */
static int
timer_intr_init(unsigned const time)
{
    if (timer_intr_id == -1) {
        // Spawn a timer thread.
        if (verbose) {
            printf("Create timer IST\n");
        }

        pthread_t tid;
        int const rc = pthread_create(&tid, NULL, timer_ist, NULL);
        if (rc != 0) {
            return rc;
        }
    }

    // Update the match register if needed.
    unsigned    next = timer_regs[REG_STCLO] - timer_regs[REG_STC1];
    if (next > time) {
        timer_regs[REG_STC1] = timer_regs[REG_STCLO] + time;
        dmb();
    }

    // Indicate to the ISR that everything is ready.
    timer_intr_ready = 1;
    return 0;
}

/**
 * Disables interrupt-based software PWM when PWM is stopped on the last GPIO.
 */
static void
timer_intr_check_done()
{
    if (timer_intr_id == -1) {
        // Timer interrupt already detached.
        return;
    }

    // Check if there are any active software PWM entries left.
    for (unsigned i = 0; i < NUM_SOFT_PWM; i++) {
        if (soft_pwm[i].duty != 0) {
            return;
        }
    }

    timer_intr_ready = 0;
    dsb();

    // Interrupt no longer required.
    timer_intr_ready = 0;
}

/**
 * PWM module initialization.
 * Maps the required hardware registers.
 * @return  Non-zero if successful, 0 otherwise
 */
int
pwm_init()
{
    // Map the PWM registers.
    pwm_regs = mmap(0, __PAGESIZE,
                    PROT_READ | PROT_WRITE | PROT_NOCACHE,
                    MAP_SHARED | MAP_PHYS,
                    -1, base_paddr + 0x20c000);

    if (pwm_regs == MAP_FAILED) {
        perror("mmap");
        return 0;
    }

    // Map the clock registers.
    clk_regs = mmap(0, __PAGESIZE,
                    PROT_READ | PROT_WRITE | PROT_NOCACHE,
                    MAP_SHARED | MAP_PHYS,
                    -1, base_paddr + 0x101000);

    if (clk_regs == MAP_FAILED) {
        perror("mmap");
        return 0;
    }

    // Map the system timer registers.
    timer_regs = mmap(0, __PAGESIZE,
                      PROT_READ | PROT_WRITE | PROT_NOCACHE,
                      MAP_PHYS | MAP_SHARED, -1, base_paddr + 0x3000);
    if (timer_regs == MAP_FAILED) {
        perror("mmap");
        return 1;
    }

    return 1;
}

/**
 * Enables hardware PWM.
 * Hardware PWM is based on the undocumented PWM clock, with a frequency of
 * 19.2MHz. The clock is associated with a divisor, which is set based on the
 * given frequency and range. The range is also recorded in the PWM range
 * register for the appropriate channel.
 * @param   pwm     A pwm_t structure for a hardware-PWM-enabled GPIO
 * @param   msg     RPI_GPIO_PWM_SETUP message
 * @return  0 if successful, error code otherwise
 */
static int
setup_pwm_hard(pwm_t const * const pwm, rpi_gpio_pwm_t const * const msg)
{
    unsigned const  frequency = msg->frequency;
    unsigned const  range = msg->range;

    if (range > 4095) {
        return EINVAL;
    }

    uint32_t    pwm_enable;
    uint32_t    pwm_enable_shift;

    if (pwm->channel == 1) {
        pwm_enable_shift = 0;
    } else {
        pwm_enable_shift = 8;
    }

    // Clear the affected channel bits.
    pwm_enable = pwm_regs[REG_PWMCTL];
    pwm_enable &= (0xff00 >> pwm_enable_shift);

    switch (msg->mode) {
    case RPI_PWM_MODE_PWM:
        pwm_enable |= ((1 << 0) << pwm_enable_shift);
        break;

    case RPI_PWM_MODE_MS:
        pwm_enable |= (((1 << 7) | (1 << 0)) << pwm_enable_shift);
        break;

    default:
        return EINVAL;
    }

    // Calculate a clock divisor.
    double  oscillator;
    if (rpi_version() == RPI_VER_4) {
        oscillator = 54000000.0;
    } else {
        oscillator = 19200000.0;
    }

    double const    divd = oscillator / ((double)frequency * (double)range);
    unsigned const  divi = (unsigned)divd;

    if ((divi < 1) || (divi > 4095)) {
        return ERANGE;
    }

    // Stop PWM.
    pwm_regs[REG_PWMCTL] = 0;

    // Stop clock and wait for it to become idle.
    clk_regs[40] = 0x5A000001;
    nanospin_ns(100000);

    while (clk_regs[40] & 0x80) {
        nanospin_ns(1000);
    }

    // Write a new divisor and restart clock.
    clk_regs[41] = 0x5A000000 | (divi << 12);
    clk_regs[40] = 0x5A000011;

    // Set range.
    pwm_regs[(pwm->channel == 1) ? REG_PWMRNG1 : REG_PWMRNG2] = range;

    // Enable PWM channel 1 in the requested mode.
    // FIXME:
    // Without the short delay PWM doesn't start in M/S mode. It's not clear
    // why.
    nanospin_ns(1000);
    pwm_regs[REG_PWMCTL] = pwm_enable;

    rpi_gpio_set_select(pwm->gpio, pwm->func);

    return 0;
}

/**
 * Handles a RPI_GPIO_PWM_SETUP message.
 * Intializes the appropriate PWM method (hardware or software) for the
 * requested GPIO, with the given frequency and range values.
 * PWM doesn't start until a duty cycle value is given to pwm_set_duty_cycle().
 * @param   rcvid   Requesting client
 * @param   msg     RPI_GPIO_PWM_SETUP message
 * @return  0 if successful, error code otherwise
 */
int
pwm_setup(rcvid_t const rcvid, rpi_gpio_pwm_t const * const msg)
{
    unsigned const  gpio = msg->gpio;
    pwm_t           *pwm = pwm_map[gpio];

    if (pwm == NULL) {
        // Find an available slot.
        for (unsigned i = 0; i < NUM_SOFT_PWM; i++) {
            if (soft_pwm[i].rcvid == 0) {
                pwm = &soft_pwm[i];
                pwm->gpio = gpio;
                break;
            }
        }

        if (pwm == NULL) {
            return EAGAIN;
        }
    } else {
        if ((pwm->rcvid != 0) && (pwm->rcvid != rcvid)) {
            return EBUSY;
        }
    }

    unsigned const  frequency = msg->frequency;
    unsigned const  range = msg->range;

    if (pwm->channel != 0) {
        // Hardware PWM.
        int const   rc = setup_pwm_hard(pwm, msg);
        if (rc != 0) {
            return rc;
        }
    } else {
        // Software PWM, make sure the GPIO is in output mode.
        rpi_gpio_set_select(gpio, 1);
    }

    pwm->rcvid = rcvid;
    pwm->range = range;
    pwm->frequency = frequency;
    pwm_map[gpio] = pwm;
    return 0;
}

/**
 * Sets the duty cycle for a PWM-enabled GPIO.
 * The duty parameter is expressed in ticks, with the resulting duty cycle being
 * the fraction of this value out of the range value defined by a call to
 * pwm_setup(). For example, a range of 800 and a duty value of 200 results in a
 * duty cycle of 25%.
 * @param   rcvid   Requesting client
 * @param   gpio    The GPIO number
 * @param   duty    Duty cycle, in ticks
 * @return  0 if successful, error code otherwise
 */
int
pwm_set_duty_cycle(rcvid_t const rcvid, unsigned const gpio, unsigned const duty)
{
    pwm_t   *pwm = pwm_map[gpio];

    if (pwm == NULL) {
        // Set up with default values.
        rpi_gpio_pwm_t const    msg = {
            .gpio = gpio,
            .frequency = 1000,
            .range = 1024
        };
        int rc = pwm_setup(rcvid, &msg);
        if (rc != 0) {
            return rc;
        }
    }

    if (pwm->channel != 0) {
        // Hardware PWM.
        pwm_regs[(pwm->channel == 1) ? REG_PWMDATA1 : REG_PWMDATA2] = duty;
        return 0;
    }

    // Software PWM.
    if ((duty == 0) || (duty >= pwm->range)) {
        // Value calls for the GPIO to be in a constant state.
        // Disable PWM on the GPIO.
        pwm->duty = 0;
        dmb();

        // Toggle GPIO to the desired state.
        if (duty == 0) {
            rpi_gpio_clear(gpio);
        } else {
            rpi_gpio_set(gpio);
        }

        // Check if we still need the timer.
        timer_intr_check_done();
        return 0;
    }

    // Calcuate on and off times is microseconds (the hardware timer works at
    // 1MHz).
    double  divd = 1000000 / ((double)pwm->frequency * (double)pwm->range);
    pwm->time_on = (unsigned)((double)duty / divd);
    pwm->time_off = (unsigned)((double)(pwm->range - duty) / divd);

    // Turn on the GPIO and capture the current time.
    rpi_gpio_set(gpio);
    pwm->state = 1;
    pwm->last_change = timer_regs[REG_STCLO];
    dmb();
    pwm->duty = duty;

    // Attach the ISR, if not already attached.
    return timer_intr_init(pwm->time_on);
}

/**
 * Resets any PWM-enabled GPIOs registered by the client.
 * @param   rcvid   The client identifier
 */
void
pwm_remove_rcvid(rcvid_t const rcvid)
{
    for (unsigned gpio = 0; gpio < RPI_GPIO_NUM; gpio++) {
        if (pwm_map[gpio] != NULL) {
            pwm_set_duty_cycle(rcvid, gpio, 0);
            pwm_map[gpio]->rcvid = 0;
            if (pwm_map[gpio]->channel == 0) {
                // Release a soft PWM slot.
                pwm_map[gpio] = NULL;
            }
        }
    }
}

void
pwm_debug(unsigned gpio)
{
    pwm_t   *pwm = pwm_map[gpio];
    if (pwm == NULL) {
        printf("PWM not enabled for GPIO %u\n", gpio);
        return;
    }

    printf("GPIO=%u f/r/d=%u/%u/%u on=%uus off=%uus last=%u\n", pwm->gpio,
           pwm->frequency, pwm->range, pwm->duty, pwm->time_on, pwm->time_off,
           pwm->last_change);
    printf("time=%u match=%u interrupts=%u\n", timer_regs[REG_STCLO],
           timer_regs[REG_STC1], timer_intrs);
}
